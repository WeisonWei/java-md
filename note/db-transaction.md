数据库事务的隔离级别有4个，由低到高依次为:
- Read uncommitted [允许脏读，可能读取到其他会话中未提交事务修改的数据] --出现-->脏读&不可重复读&幻读 
- Read committed [只能读取到已经提交的数据] --出现-->不可重复读&幻读 --解决-->脏读 
- Repeatable read [在同一个事务内的查询都是事务开始时刻一致的] --出现-->幻读 --解决-->不可重复读 
- Serializable [完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞] --解决-->幻读 

这四个级别可以逐个解决 脏读、不可重复读 、幻读问题;

- 脏读：事务A读了事务B没提交的数据(未确认的相关性)
- 不可重复读：(不一致的分析)
- 幻读: (丢失或覆盖更新)


[MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来实现]


**事务并发产生的问题**
- 脏读：一个事务读取到了另外一个事务没有提交的数据
    事务1：更新一条数据
    ------------->事务2：读取事务1更新的记录
    事务1：调用commit进行提交
           
    ***此时事务2读取到的数据是保存在数据库内存中的数据，称为脏读。
    ***读到的数据为脏数据
    详细解释：
       脏读就是指:当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，
       另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个
       事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。
           
- 不可重复读：在同一事务中，两次读取同一数据，得到内容不同
       事务1：查询一条记录
        -------------->事务2：更新事务1查询的记录
        -------------->事务2：调用commit进行提交
       事务1：再次查询上次的记录
         ***此时事务1对同一数据查询了两次，可得到的内容不同，称为不可重复读
           
- 幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同
    事务1：查询表中所有记录
    -------------->事务2：插入一条记录
    -------------->事务2：调用commit进行提交
    事务1：再次查询表中所有记录
           
    ***此时事务1两次查询到的记录是不一样的，称为幻读
    详细解释：
    幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，
    这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表
    中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，
    就好象发生了幻觉一样。

处理以上隔离级别的问题，采用如下方是：

事务隔离五种级别：
- `TRANSACTION_NONE  不使用事务`
- `RANSACTION_READ_UNCOMMITTED  允许脏读`
- `TRANSACTION_READ_COMMITTED  防止脏读，最常用的隔离级别,并且是大多数数据库的默认隔离级别`
- `TRANSACTION_REPEATABLE_READ  可以防止脏读和不可重复读`
- `TRANSACTION_SERIALIZABLE  可以防止脏读，不可重复读取和幻读，（事务串行化）会降低数据库的效率`
